<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Ale Abbey Rezept-Solver</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
  <div class="page">
    <header>
      <h1>üç∫ Ale Abbey ‚Äì Rezept-Solver</h1>
      <p>W√§hle f√ºr jede Eigenschaft die gew√ºnschte Farbzone und lege exakte Wertebereiche fest. Die Berechnung l√§uft vollst√§ndig im Browser und ber√ºcksichtigt Pflichtzutaten, Mengenlimits und optionale W√ºnsche.</p>
    </header>

    <form class="card form-card" data-solver-form>
      <section>
        <h3 class="section-title">Grunddaten</h3>
        <div class="grid-two">
          <label>
            <span class="label">Bierstil</span>
            <select name="style">
              {% for s in styles %}
                <option value="{{ s }}" {% if s == style %}selected{% endif %}>{{ s }}</option>
              {% endfor %}
            </select>
          </label>
          <label>
            <span class="label">Gesamtanzahl Zutaten (Cap)</span>
            <input type="number" name="total_cap" min="1" max="30" value="{{ total_cap }}">
          </label>
          <label>
            <span class="label">Max pro Zutat</span>
            <input type="number" name="per_cap" min="1" max="30" value="{{ per_cap }}">
          </label>
        </div>
      </section>

      <section>
        <div class="section-header">
          <h3 class="section-title">Attribute</h3>
          <button type="button" class="btn-secondary" data-set-all-green>Alle Attribute auf Gr√ºn</button>
        </div>
        <div class="attr-grid">
          {% for a in attrs %}
            <div class="attr-card" data-attr-card>
              <h4>{{ attr_labels[a] }}</h4>
              <div class="chips">
                {% for band in ['any', 'green', 'yellow', 'red'] %}
                  {% set label = band_labels.get(band, band) %}
                  <label class="chip" data-color="{{ band }}">
                    <input type="radio" name="band_{{ a }}" value="{{ band }}" {% if constraints[a].band == band %}checked{% endif %}>
                    <span>{{ label }}</span>
                  </label>
                {% endfor %}
              </div>

              <div>
                <label class="label" style="margin-top:12px;">Modus</label>
                <select class="mode-select" name="mode_{{ a }}">
                  <option value="any" {% if constraints[a].mode == 'any' %}selected{% endif %}>Egal</option>
                  <option value="ge" {% if constraints[a].mode == 'ge' %}selected{% endif %}>Mindestens</option>
                  <option value="le" {% if constraints[a].mode == 'le' %}selected{% endif %}>H√∂chstens</option>
                  <option value="between" {% if constraints[a].mode == 'between' %}selected{% endif %}>Zwischen</option>
                </select>
                <div class="range-inputs">
                  <label>Untergrenze
                    <input type="number" class="min-input" name="min_{{ a }}" step="0.1" min="0" max="11" value="{{ constraints[a].min }}">
                  </label>
                  <label>Obergrenze
                    <input type="number" class="max-input" name="max_{{ a }}" step="0.1" min="0" max="11" value="{{ constraints[a].max }}">
                  </label>
                </div>
                <p class="hint">Wertebereich 0.0 ‚Äì 11.0, eine Nachkommastelle.</p>
              </div>
            </div>
          {% endfor %}
        </div>
      </section>

      <section>
        <details class="collapsible" data-collapsible open>
          <summary>
            <h3 class="section-title">Zutaten√ºbersicht</h3>
          </summary>
          <div class="table-wrapper">
            <table class="ingredients-table">
              <thead>
                <tr>
                  <th class="col-checkbox"></th>
                  <th>Name</th>
                  <th>Geschmack</th>
                  <th>Farbe</th>
                  <th>St√§rke</th>
                  <th>Schaum</th>
                </tr>
              </thead>
              <tbody>
                {% for ing in ingredients %}
                  {% set required_count = style_mins.get(ing.name, 0) %}
                  {% set is_required = required_count > 0 %}
                  {% set is_locked = is_required %}
                  {% set is_checked = is_locked or ing.name in selected_optional %}
                  <tr class="{% if is_locked %}ingredient-locked{% endif %}" data-ingredient-row data-ingredient-name="{{ ing.name }}">
                    <td class="checkbox-cell">
                      <label class="ingredient-option" {% if is_locked %}title="Diese Zutat ist vorgegeben."{% endif %}>
                        <input type="checkbox" name="optional_ingredients" value="{{ ing.name }}" {% if is_checked %}checked{% endif %} {% if is_locked %}disabled{% endif %} data-user-selected="{{ 'true' if ing.name in selected_optional else 'false' }}">
                        <span class="checkbox-visual"></span>
                      </label>
                    </td>
                    <td>
                      <div class="ingredient-name">
                        <span>{{ ing.name }}</span>
                        <span class="ingredient-badge badge-required" data-required-badge {% if not is_required %}hidden{% endif %}>
                          {% if is_required %}
                            Pflicht{% if required_count > 1 %} √ó {{ required_count }}{% endif %}
                          {% else %}
                            Pflicht
                          {% endif %}
                        </span>
                      </div>
                    </td>
                    <td>{{ '%.1f'|format(ing.vec[0]) }}</td>
                    <td>{{ '%.1f'|format(ing.vec[1]) }}</td>
                    <td>{{ '%.1f'|format(ing.vec[2]) }}</td>
                    <td>{{ '%.1f'|format(ing.vec[3]) }}</td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </details>
      </section>

      <button class="btn-primary" type="submit" data-submit-button {% if not has_active_constraints %}disabled{% endif %}>Rezept berechnen</button>
    </form>

    <section class="results-section" data-results hidden style="margin-top: 32px;">
      <h2 class="section-title" data-results-title>Ergebnisse</h2>
      <p class="hint" data-results-summary></p>
      <p class="hint" data-status-message hidden></p>
      <p data-results-empty hidden><strong>Keine L√∂sung</strong> unter den gegebenen Regeln gefunden.</p>
      <div class="grid-two" data-results-list></div>
    </section>

    <section style="margin-top: 36px;" class="card">
      <details>
        <summary>JSON ansehen</summary>
        <h3 style="margin-top:16px;">Zutaten</h3>
        <pre class="mono">{{ ingredients_json }}</pre>
        <h3>Bierstile</h3>
        <pre class="mono">{{ styles_json }}</pre>
      </details>
      <hr>
      <details open hidden data-debug-panel>
        <summary>Debug</summary>
        <pre class="mono" data-debug-output></pre>
      </details>
    </section>
  </div>

  <script id="ingredients-data" type="application/json">{{ ingredients_data | tojson }}</script>
  <script id="styles-data" type="application/json">{{ styles_data | tojson }}</script>
  <script id="meta-data" type="application/json">{{ {'attrs': attrs, 'attr_labels': attr_labels, 'band_labels': band_labels} | tojson }}</script>
  <script id="style-min-data" type="application/json">{{ style_min_map | tojson }}</script>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const parseJSONScript = (id, fallback) => {
        const el = document.getElementById(id);
        if (!el) return fallback;
        try {
          const txt = el.textContent || el.innerText || '';
          return txt ? JSON.parse(txt) : fallback;
        } catch (err) {
          console.error(`Konnte ${id} nicht parsen`, err);
          return fallback;
        }
      };

      const styleMinMap = parseJSONScript('style-min-data', {});
      const ingredients = parseJSONScript('ingredients-data', []);
      const stylesData = parseJSONScript('styles-data', {});
      const metaData = parseJSONScript('meta-data', {});
      const styleNames = Object.keys(stylesData);
      const ATTRS = metaData.attrs || ['taste', 'color', 'strength', 'foam'];
      const attrLabels = metaData.attr_labels || metaData.attrLabels || {};
      const bandLabels = metaData.band_labels || metaData.bandLabels || {};
      const EPS = 1e-9;

      const attrCards = Array.from(document.querySelectorAll('[data-attr-card]'));
      const submitBtn = document.querySelector('[data-submit-button]');
      const setAllGreenBtn = document.querySelector('[data-set-all-green]');
      const styleSelect = document.querySelector('select[name="style"]');
      const ingredientRows = Array.from(document.querySelectorAll('[data-ingredient-row]'));
      const form = document.querySelector('[data-solver-form]');

      const resultsSection = document.querySelector('[data-results]');
      const resultsTitle = document.querySelector('[data-results-title]');
      const resultsSummary = document.querySelector('[data-results-summary]');
      const resultsList = document.querySelector('[data-results-list]');
      const resultsEmpty = document.querySelector('[data-results-empty]');
      const statusMessage = document.querySelector('[data-status-message]');
      const debugPanel = document.querySelector('[data-debug-panel]');
      const debugOutput = document.querySelector('[data-debug-output]');

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const detectBand = (style, attr, value) => {
        const segments = (style.bands && style.bands[attr]) || [];
        for (const seg of segments) {
          if (value >= (seg.min ?? 0) - EPS && value <= (seg.max ?? 0) + EPS) {
            return seg.band;
          }
        }
        return null;
      };

      const intersectInterval = (a, b) => {
        const lo = Math.max(a[0], b[0]);
        const hi = Math.min(a[1], b[1]);
        return lo <= hi ? [lo, hi] : null;
      };

      const solveRecipe = ({
        styleName,
        numericIntervals,
        bandPreferences,
        totalCap,
        perCap,
        extraMinCounts,
        topK = 10,
      }) => {
        const style = stylesData[styleName];
        if (!style) {
          return { solutions: [], info: ['Unbekannter Stil: ' + styleName] };
        }

        const n = ingredients.length;
        const base = (style.base || [0, 0, 0, 0]).map(Number);
        const vectors = ingredients.map(ing => (ing.vec || [0, 0, 0, 0]).map(Number));
        const nameToIndex = new Map(ingredients.map((ing, idx) => [ing.name, idx]));

        const minCounts = new Array(n).fill(0);
        const mandatory = style.min_counts || {};
        Object.entries(mandatory).forEach(([name, cnt]) => {
          if (nameToIndex.has(name)) {
            const idx = nameToIndex.get(name);
            minCounts[idx] = Math.max(minCounts[idx], Number(cnt) || 0);
          }
        });
        if (extraMinCounts) {
          Object.entries(extraMinCounts).forEach(([name, cnt]) => {
            if (nameToIndex.has(name)) {
              const idx = nameToIndex.get(name);
              minCounts[idx] = Math.max(minCounts[idx], Number(cnt) || 0);
            }
          });
        }

        if (minCounts.some(cnt => cnt > perCap)) {
          return { solutions: [], info: ['Pflichtanzahl √ºbersteigt das Zutatencap.'] };
        }

        const minSum = minCounts.reduce((acc, val) => acc + val, 0);
        totalCap = Math.max(totalCap, minSum);

        const perAttrIntervals = ATTRS.map(attr => numericIntervals[attr]);
        const allowedBandMap = {};
        ATTRS.forEach(attr => {
          const pref = bandPreferences[attr];
          allowedBandMap[attr] = pref ? [...pref] : null;
        });

        const allowedIntervalsForAttr = (attr, allowedBands) => {
          const startInterval = perAttrIntervals[ATTRS.indexOf(attr)] || [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY];
          if (!allowedBands || allowedBands.length === 0) {
            return [startInterval];
          }
          const out = [];
          const segments = (style.bands && style.bands[attr]) || [];
          for (const band of allowedBands) {
            for (const seg of segments) {
              if (seg.band !== band) continue;
              const iv = intersectInterval(startInterval, [seg.min ?? 0, seg.max ?? 0]);
              if (iv && !out.some(existing => Math.abs(existing[0] - iv[0]) < EPS && Math.abs(existing[1] - iv[1]) < EPS)) {
                out.push(iv);
              }
            }
          }
          return out;
        };

        const perAttrLists = ATTRS.map(attr => allowedIntervalsForAttr(attr, allowedBandMap[attr]));
        if (perAttrLists.some(list => list.length === 0)) {
          return { solutions: [], info: ['Keine passenden Intervalle f√ºr die gew√§hlten B√§nder.'] };
        }

        const suffixMinCounts = new Array(n + 1).fill(0);
        for (let idx = n - 1; idx >= 0; idx -= 1) {
          suffixMinCounts[idx] = minCounts[idx] + suffixMinCounts[idx + 1];
        }
        if (suffixMinCounts[0] > totalCap) {
          return { solutions: [], info: ['Gesamtcap ist kleiner als die Summe der Pflichtzutaten.'] };
        }

        const suffixLo = Array.from({ length: n + 1 }, () => new Array(ATTRS.length).fill(0));
        const suffixHi = Array.from({ length: n + 1 }, () => new Array(ATTRS.length).fill(0));
        for (let idx = n - 1; idx >= 0; idx -= 1) {
          const vec = vectors[idx];
          const loCnt = minCounts[idx];
          const hiCnt = perCap;
          for (let k = 0; k < ATTRS.length; k += 1) {
            const coef = vec[k] || 0;
            const loVal = coef >= 0 ? coef * loCnt : coef * hiCnt;
            const hiVal = coef >= 0 ? coef * hiCnt : coef * loCnt;
            suffixLo[idx][k] = loVal + suffixLo[idx + 1][k];
            suffixHi[idx][k] = hiVal + suffixHi[idx + 1][k];
          }
        }

        const counts = new Array(n).fill(0);
        const seenCombos = new Set();
        const solutions = [];

        const iterateBoxes = (attrIdx, lower, upper) => {
          if (attrIdx === ATTRS.length) {
            const lowerBounds = lower.slice();
            const upperBounds = upper.slice();

            const dfs = (idx, used, totals) => {
              if (idx >= n) {
                for (let k = 0; k < ATTRS.length; k += 1) {
                  if (totals[k] < lowerBounds[k] - EPS || totals[k] > upperBounds[k] + EPS) {
                    return;
                  }
                }
                const key = counts.join('|');
                if (seenCombos.has(key)) {
                  return;
                }
                seenCombos.add(key);

                const bands = {};
                for (let k = 0; k < ATTRS.length; k += 1) {
                  const attr = ATTRS[k];
                  bands[attr] = detectBand(style, attr, totals[k]) || 'n/a';
                }

                const countsByName = {};
                counts.forEach((cnt, idx2) => {
                  if (cnt > 0) {
                    countsByName[ingredients[idx2].name] = cnt;
                  }
                });

                const totalsRounded = totals.map(val => Math.round(val * 1000) / 1000);
                solutions.push({
                  x: counts.slice(),
                  sum: counts.reduce((acc, val) => acc + val, 0),
                  totals: totalsRounded,
                  bands,
                  countsByName,
                });
                return;
              }

              if (used + suffixMinCounts[idx] > totalCap) {
                return;
              }
              for (let k = 0; k < ATTRS.length; k += 1) {
                const minPossible = totals[k] + suffixLo[idx][k];
                const maxPossible = totals[k] + suffixHi[idx][k];
                if (maxPossible < lowerBounds[k] - EPS || minPossible > upperBounds[k] + EPS) {
                  return;
                }
              }

              const remainingMinAfter = suffixMinCounts[idx + 1];
              const maxC = Math.min(perCap, totalCap - used - remainingMinAfter);
              const minC = minCounts[idx];
              if (maxC < minC) {
                return;
              }

              const vec = vectors[idx];
              for (let c = minC; c <= maxC; c += 1) {
                counts[idx] = c;
                const newTotals = totals.map((val, k) => val + (vec[k] || 0) * c);
                let feasible = true;
                for (let k = 0; k < ATTRS.length; k += 1) {
                  const minPossible = newTotals[k] + suffixLo[idx + 1][k];
                  const maxPossible = newTotals[k] + suffixHi[idx + 1][k];
                  if (maxPossible < lowerBounds[k] - EPS || minPossible > upperBounds[k] + EPS) {
                    feasible = false;
                    break;
                  }
                }
                if (feasible) {
                  dfs(idx + 1, used + c, newTotals);
                }
              }
              counts[idx] = 0;
            };

            dfs(0, 0, base.slice());
            return;
          }

          for (const interval of perAttrLists[attrIdx]) {
            lower[attrIdx] = interval[0];
            upper[attrIdx] = interval[1];
            iterateBoxes(attrIdx + 1, lower, upper);
          }
        };

        iterateBoxes(0, new Array(ATTRS.length).fill(Number.NEGATIVE_INFINITY), new Array(ATTRS.length).fill(Number.POSITIVE_INFINITY));

        solutions.sort((a, b) => {
          if (a.sum !== b.sum) return a.sum - b.sum;
          for (let k = 0; k < ATTRS.length; k += 1) {
            const diff = a.totals[k] - b.totals[k];
            if (Math.abs(diff) > EPS) return diff;
          }
          for (let i = 0; i < a.x.length; i += 1) {
            if (a.x[i] !== b.x[i]) return a.x[i] - b.x[i];
          }
          return 0;
        });

        const uniq = [];
        const seen = new Set();
        for (const s of solutions) {
          const key = s.x.join('|');
          if (seen.has(key)) continue;
          seen.add(key);
          uniq.push(s);
          if (uniq.length >= topK) break;
        }

        return { solutions: uniq, info: [] };
      };

      const updateSubmitState = () => {
        if (!submitBtn) return;
        const hasConstraint = attrCards.some(card => {
          const selectedBand = card.querySelector('input[type="radio"]:checked');
          const modeSelect = card.querySelector('.mode-select');
          const bandActive = selectedBand && selectedBand.value !== 'any';
          const modeActive = modeSelect && modeSelect.value !== 'any';
          return bandActive || modeActive;
        });
        submitBtn.disabled = !hasConstraint;
      };

      attrCards.forEach(card => {
        const modeSelect = card.querySelector('.mode-select');
        const minInput = card.querySelector('.min-input');
        const maxInput = card.querySelector('.max-input');

        const toggle = () => {
          const mode = modeSelect.value;
          if (mode === 'any') {
            minInput.disabled = true;
            maxInput.disabled = true;
          } else if (mode === 'ge') {
            minInput.disabled = false;
            maxInput.disabled = true;
          } else if (mode === 'le') {
            minInput.disabled = true;
            maxInput.disabled = false;
          } else {
            minInput.disabled = false;
            maxInput.disabled = false;
          }
          updateSubmitState();
        };

        toggle();
        modeSelect.addEventListener('change', toggle);
        card.querySelectorAll('input[type="radio"]').forEach(radio => {
          radio.addEventListener('change', updateSubmitState);
        });
      });

      if (setAllGreenBtn) {
        setAllGreenBtn.addEventListener('click', () => {
          attrCards.forEach(card => {
            const greenRadio = card.querySelector('input[type="radio"][value="green"]');
            if (greenRadio) {
              greenRadio.checked = true;
            }
          });
          updateSubmitState();
        });
      }

      ingredientRows.forEach(row => {
        const checkbox = row.querySelector('input[type="checkbox"]');
        if (!checkbox) return;
        checkbox.addEventListener('change', () => {
          checkbox.dataset.userSelected = checkbox.checked ? 'true' : 'false';
        });
      });

      const applyStyleRequirements = (styleName) => {
        if (!styleName) return;
        const activeMins = styleMinMap[styleName] || {};

        ingredientRows.forEach(row => {
          const ingredientName = row.dataset.ingredientName;
          const checkbox = row.querySelector('input[type="checkbox"]');
          const label = row.querySelector('.ingredient-option');
          const badge = row.querySelector('[data-required-badge]');
          if (!checkbox || !ingredientName) {
            return;
          }
          const requiredCount = activeMins[ingredientName] || 0;
          if (requiredCount > 0) {
            row.classList.add('ingredient-locked');
            checkbox.checked = true;
            checkbox.disabled = true;
            checkbox.dataset.userSelected = 'false';
            if (label) {
              label.title = 'Diese Zutat ist vorgegeben.';
            }
            if (badge) {
              badge.hidden = false;
              badge.textContent = requiredCount > 1 ? `Pflicht √ó ${requiredCount}` : 'Pflicht';
            }
          } else {
            row.classList.remove('ingredient-locked');
            checkbox.disabled = false;
            const userSelected = checkbox.dataset.userSelected === 'true';
            checkbox.checked = userSelected;
            if (label) {
              label.removeAttribute('title');
            }
            if (badge) {
              badge.hidden = true;
            }
          }
        });
      };

      if (styleSelect) {
        styleSelect.addEventListener('change', () => {
          applyStyleRequirements(styleSelect.value);
        });
        applyStyleRequirements(styleSelect.value);
      }

      updateSubmitState();

      const parseFloatOrNull = value => {
        if (value === null || value === undefined) return null;
        const trimmed = String(value).trim();
        if (!trimmed) return null;
        const parsed = Number(trimmed);
        return Number.isFinite(parsed) ? parsed : null;
      };

      const formatIntervalValue = value => {
        if (!Number.isFinite(value)) {
          return value < 0 ? '-‚àû' : '‚àû';
        }
        return value.toFixed(2);
      };

      const renderSolutions = (solutions, summaryLines, infoMessages) => {
        if (!resultsSection) return;
        resultsSection.hidden = false;
        const count = solutions.length;
        if (resultsTitle) {
          resultsTitle.textContent = `Ergebnisse (${count})`;
        }
        if (resultsSummary) {
          if (summaryLines.length) {
            resultsSummary.hidden = false;
            resultsSummary.textContent = summaryLines.join(' ‚Ä¢ ');
          } else {
            resultsSummary.hidden = true;
            resultsSummary.textContent = '';
          }
        }
        if (statusMessage) {
          if (infoMessages.length > 0) {
            statusMessage.hidden = false;
            statusMessage.textContent = infoMessages.join(' ');
          } else {
            statusMessage.hidden = true;
            statusMessage.textContent = '';
          }
        }
        if (resultsEmpty) {
          resultsEmpty.hidden = count !== 0;
        }
        if (resultsList) {
          resultsList.innerHTML = '';
        }
        if (count === 0) {
          return;
        }

        solutions.forEach(solution => {
          const card = document.createElement('div');
          card.className = 'card';

          const heading = document.createElement('h3');
          heading.style.marginTop = '0';
          heading.textContent = `Gesamtzutaten: ${solution.sum}`;
          card.appendChild(heading);

          const mixTitle = document.createElement('p');
          mixTitle.style.marginBottom = '8px';
          mixTitle.style.fontWeight = '600';
          mixTitle.textContent = 'Zutatenmix';
          card.appendChild(mixTitle);

          const chipsContainer = document.createElement('div');
          chipsContainer.className = 'chips';
          chipsContainer.style.marginBottom = '12px';
          Object.entries(solution.countsByName).forEach(([name, cnt]) => {
            const chip = document.createElement('span');
            chip.className = 'chip';
            const span = document.createElement('span');
            span.textContent = `${name} √ó ${cnt}`;
            chip.appendChild(span);
            chipsContainer.appendChild(chip);
          });
          card.appendChild(chipsContainer);

          const totalsText = document.createElement('p');
          totalsText.style.margin = '0 0 10px';
          totalsText.textContent = `Geschmack ${solution.totals[0]}, Farbe ${solution.totals[1]}, St√§rke ${solution.totals[2]}, Schaum ${solution.totals[3]}`;
          card.appendChild(totalsText);

          const pillContainer = document.createElement('div');
          pillContainer.style.display = 'flex';
          pillContainer.style.flexWrap = 'wrap';
          pillContainer.style.gap = '8px';
          pillContainer.style.marginBottom = '12px';
          ATTRS.forEach((attr, idx) => {
            const band = solution.bands[attr];
            const pill = document.createElement('span');
            pill.className = `pill ${String(band).replace(/\//g, '-')}`;
            const label = attrLabels[attr] || attr;
            pill.textContent = `${label}: ${bandLabels[band] || band}`;
            pillContainer.appendChild(pill);
          });
          card.appendChild(pillContainer);

          const details = document.createElement('details');
          const summary = document.createElement('summary');
          summary.textContent = 'Roh-Vektor';
          details.appendChild(summary);
          const pre = document.createElement('pre');
          pre.className = 'mono';
          pre.textContent = JSON.stringify(solution.x);
          details.appendChild(pre);
          card.appendChild(details);

          resultsList.appendChild(card);
        });
      };

      const renderDebug = (lines) => {
        if (!debugPanel || !debugOutput) return;
        if (!lines.length) {
          debugPanel.hidden = true;
          debugOutput.textContent = '';
          return;
        }
        debugPanel.hidden = false;
        debugOutput.textContent = lines.join('\n');
      };

      if (form) {
        form.addEventListener('submit', (event) => {
          event.preventDefault();
          const formData = new FormData(form);
          let styleName = formData.get('style') || (styleNames.length ? styleNames[0] : null);
          if (styleName && !(styleName in stylesData) && styleNames.length) {
            styleName = styleNames[0];
          }
          const totalCapRaw = Number(formData.get('total_cap'));
          const perCapRaw = Number(formData.get('per_cap'));
          const totalCap = clamp(Number.isFinite(totalCapRaw) ? totalCapRaw : 25, 1, 99);
          const perCap = clamp(Number.isFinite(perCapRaw) ? perCapRaw : 25, 1, 99);

          const numericIntervals = {};
          const bandPreferences = {};
          const debugIntervals = {};
          const debugLines = [];

          ATTRS.forEach(attr => {
            const bandChoice = formData.get(`band_${attr}`) || 'any';
            bandPreferences[attr] = bandChoice === 'any' ? null : [bandChoice];

            const mode = formData.get(`mode_${attr}`) || 'any';
            const rawMin = parseFloatOrNull(formData.get(`min_${attr}`));
            const rawMax = parseFloatOrNull(formData.get(`max_${attr}`));
            const minVal = rawMin === null ? null : clamp(rawMin, 0, 11);
            const maxVal = rawMax === null ? null : clamp(rawMax, 0, 11);
            let lo = Number.NEGATIVE_INFINITY;
            let hi = Number.POSITIVE_INFINITY;
            let debugLo = 0;
            let debugHi = 11;
            if (mode === 'ge') {
              lo = minVal === null ? 0 : minVal;
              debugLo = lo;
              debugHi = Number.POSITIVE_INFINITY;
            } else if (mode === 'le') {
              hi = maxVal === null ? 11 : maxVal;
              debugLo = Number.NEGATIVE_INFINITY;
              debugHi = hi;
            } else if (mode === 'between') {
              const lower = Math.min(minVal === null ? 0 : minVal, maxVal === null ? 11 : maxVal);
              const upper = Math.max(minVal === null ? 0 : minVal, maxVal === null ? 11 : maxVal);
              lo = lower;
              hi = upper;
              debugLo = lower;
              debugHi = upper;
            } else {
              debugLo = 0;
              debugHi = 11;
            }
            numericIntervals[attr] = [lo, hi];
            debugIntervals[attr] = [debugLo, debugHi];
          });

          const selectedOptional = new Set(formData.getAll('optional_ingredients'));
          const extraMinCounts = {};
          selectedOptional.forEach(name => {
            extraMinCounts[name] = Math.max(extraMinCounts[name] || 0, 1);
          });

          debugLines.push(`Stil: ${styleName || '‚Äî'}`);
          debugLines.push(`Gesamt-Cap: ${totalCap}, Pro-Zutat-Cap: ${perCap}`);
          debugLines.push('Einstellungen je Attribut:');
          ATTRS.forEach(attr => {
            const interval = debugIntervals[attr] || [0, 11];
            const bandPref = bandPreferences[attr];
            const bandKey = bandPref && bandPref.length === 1 ? bandPref[0] : 'any';
            const bandText = bandLabels[bandKey] || (bandPref ? bandPref.join(', ') : 'Egal');
            debugLines.push(`  ${attrLabels[attr] || attr} ‚Üí Band: ${bandText}, Intervall: [${formatIntervalValue(interval[0])}, ${formatIntervalValue(interval[1])}]`);
          });
          if (selectedOptional.size) {
            debugLines.push('Zus√§tzliche gew√ºnschte Zutaten: ' + Array.from(selectedOptional).sort().join(', '));
          }

          const { solutions, info } = solveRecipe({
            styleName,
            numericIntervals,
            bandPreferences,
            totalCap,
            perCap,
            extraMinCounts,
          });

          const summaryLines = [];
          if (styleName) {
            summaryLines.push(`Stil: ${styleName}`);
          }
          summaryLines.push(`Cap gesamt ${totalCap}, pro Zutat ${perCap}`);
          summaryLines.push('Berechnung clientseitig');

          renderSolutions(solutions, summaryLines, info);
          renderDebug(debugLines);
        });
      }
    });
  </script>
</body>
</html>
